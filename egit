#!/bin/bash

#
# Copyright 2012 by Daniel Volk <mail@volkarts.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

__debug=0
__dry_run=0


BASE_PATH=


PROJECTS=()

	
__d()
{
	[ $__debug -eq 1 ] && echo -e "\e[1;30mDEBUG $1\e[0m"
}


__set_base()
{
	BASE_PATH=$PWD
	
	while [ "$BASE_PATH" != "" -a "$BASE_PATH" != "/" ]; do
		if [ -e "$BASE_PATH/.repo/manifest.xml" ]; then
			return 0
		fi
		
		BASE_PATH=`dirname "$BASE_PATH"`
	done
	
	return 1
}


__build_egit_manifest()
{
	if [ ! -f "$BASE_PATH/.repo/manifest.xml" ]; then
		# no android environment - skip building manifest
		return;
	fi


	if [ "$1" != "force" ]; then
		doit=0
		if [ "$BASE_PATH/.repo/manifest.xml" -nt "$BASE_PATH/.repo/egit_project.list" ]; then
			doit=1
		else
			if [ "$BASE_PATH/.repo/local_manifest.xml" -nt "$BASE_PATH/.repo/egit_project.list" ]; then
				doit=1
			else
				for f in `ls $BASE_PATH/.repo/local_manifests/*.xml 2>/dev/null`; do
					if [ "$f" -nt "$BASE_PATH/.repo/egit_project.list" ]; then
						doit=1
						break;
					fi
				done
			fi
		fi

		if [ $doit -eq 0 ]; then
			return;
		fi
	fi


	if [ \
		"$BASE_PATH/.repo/manifest.xml" -nt "$BASE_PATH/.repo/egit_project.list" -o \
		"$BASE_PATH/.repo/local_manifest.xml" -nt "$BASE_PATH/.repo/egit_project.list" -o \
		"$1" == "force" \
		]; then		
		bo=\(
		bc=\)
		t=\`
		
		PERL_CODE=$(cat <<PERL_CODE

\$file = "";

open${bo}FILE, "<$BASE_PATH/.repo/manifest.xml"$bc or die "Cannot load repo list\n";
\$file .= \$_ while ( <FILE> );
close(FILE);

if ( -e "$BASE_PATH/.repo/local_manifest.xml" )
{
	open${bo}FILE, "<$BASE_PATH/.repo/local_manifest.xml"$bc or die "Cannot load local repo list\n";
	\$file .= \$_ while ( <FILE> );
	close(FILE);
}

@local_manifests = <$BASE_PATH/.repo/local_manifests/*.xml>;
foreach \$local_manifest (@local_manifests)
{
	open${bo}FILE, "<\$local_manifest"$bc or die "Cannot load local repo list\n";
	\$file .= \$_ while ( <FILE> );
	close(FILE);
}


\$file =~ s/<!--.*?-->//g;

%projects = ();
@project_list = ();

while ( \$file =~ /<project$bo[^>]+$bc>/g )
{
	\$line = \$1;
	
	\$line =~ /name="$bo[^"]*$bc"/i;
	\$name = \$1;
	
	\$line =~ /path="$bo[^"]*$bc"/i;
	\$path = \$1;
	
	\$name = \$path if ( \$name eq "" );
	
	\$pid = "\$name:\$path";
	
	if ( !\$projects{\$path} )
	{
		push @project_list, \$path;
	}
	\$projects{\$path} = \$pid;
	
}

	
	
if ( -e "$BASE_PATH/.repo/egit_project.list" )
{
	open${bo}FILE, "<$BASE_PATH/.repo/egit_project.list"$bc or die "Cannot load egit project list\n";
	while ( <FILE> )
	{
		\$_ =~ s/[\s\r\n]+\$/\1/s;
		@pdef = split /:/;
		
		if ( \$projects{\$pdef[1]} )
		{
			if ( \$pdef[0] =~ /^#/ )
			{
				\$projects{\$pdef[1]} = "#\$projects{\$pdef[1]}"
			}
			
			if ( \$pdef[2] )
			{
				\$projects{\$pdef[1]} = "\$projects{\$pdef[1]}:\$pdef[2]";
			}
		}
	}
	close(FILE);
}


open${bo}FILE, ">$BASE_PATH/.repo/egit_project.list"$bc or die "Cannot write egit project list\n";
foreach ( @project_list )
{
	\$status = ${t}cd $BASE_PATH/\$_ && git branch | awk '/^\*/ { print \\\$1 \\\$2 \\\$3 }'$t;
	\$status =~ s/[\s\r\n]+\$/\1/s;
	
	if ( \$status !~ /^\*\(/ )
	{
		print FILE "\$projects{\$_}\n";
	}
}
close(FILE);

PERL_CODE
		)
	
		
		echo -n "### Building manifest "
		if [ "$1" == "force" ]; then echo -n "(forced)"; else echo -n "(update)"; fi
		echo " ###"
	
		echo $PERL_CODE | perl
		return $?
	fi
}	


__filter_projects()
{
	if [ $# -eq 0 ]; then
		return
	fi
	
	
	declare -a _projects=("${PROJECTS[@]}")

	PROJECTS=()
	
	for _project in "${_projects[@]}"; do
		for _arg in "$@"; do
			__d "Check $_project against $_arg"
			
			if [[ "$_project" == *$_arg* ]]; then
				PROJECTS=("${PROJECTS[@]}" "$_project")
			fi
		done
	done
}


__read_repo()
{
	desired_projects=()
	force=
	
	for _arg in "$@"; do
		if [ "$_arg" == "-f" ]; then
			force="force"
		else
			desired_projects=("${desired_projects[@]}" "$_arg")
		fi
	done

	
	__build_egit_manifest $force
	
	if [ $? -ne 0 ]; then
		exit $?
	fi
	
	
	PROJECTS=($(cat $BASE_PATH/.repo/egit_project.list | grep "^[^#]"))
	
	
	__filter_projects "${desired_projects[@]}"
}


__failed()
{
	__last_git_failed=1
	
	echo -e "\033[1;31mFailed\033[0m"
}


# return <skip> when working dir contains no changes
__repo_status()
{
	status=$(git status -s)
	
	if [ "$status" != "" ]; then
		return 0
	else
		return 255
	fi
}


__exit_hook()
{
	cd $ORIG_PATH
	
	exit 3
}


__exec_git()
{
	ORIG_PATH=$PWD
	
	trap __exit_hook INT TERM

	
	__last_git_failed=0

	
	_cmd_info=$(echo $1 | tr '[a-z]' '[A-Z]')
	shift
	
	P_RREV_U=
	P_LREV_U=
	DIR=lo
	while [ 1 = 1 ]; do
		internal_cmd=$1
		if [ "${internal_cmd:0:4}" == "!rb:" ]; then
			P_RREV_U=${internal_cmd:4}
			shift
		elif [ "${internal_cmd:0:4}" == "!lb:" ]; then
			P_LREV_U=${internal_cmd:4}
			shift
		elif [ "${internal_cmd:0:5}" == "!dir:" ]; then
			DIR=${internal_cmd:5}
			shift
		else
			break
		fi
	done
	
	
	for p in ${PROJECTS[@]}; do
		pattrs=($(echo $p | tr ":" "\n"))
		
		P_NAME=${pattrs[0]}
		P_PATH=${pattrs[1]}

		cd $BASE_PATH/$P_PATH 2>/dev/null
		if [ $? -ne 0 ]; then
			echo -e "\033[1;31mCannot switch to directory \033[0;36m$P_PATH\033[1;31m for project \033[0;36m$P_NAME\033[1;31m: Directory does not exists\033[0m"
			__failed
			break;
		fi
		
		P_LREV=$P_LREV_U
		
		if [ "$P_LREV" == "" ]; then
			P_LREV=$(git branch | awk '/^\*/ { print $2 }')
		fi
		
		
		P_RREV=$P_RREV_U
		
		if [ "$P_RREV" == "" ]; then
			P_RREV=$P_LREV
		fi

		mappings=($(echo ${pattrs[2]} | tr "," "\n"))	
		for m in "${mappings[@]}"; do
			_a=($(echo $m | tr "=" "\n"))
			
			if [ "${_a[0]}" == "$P_RREV" ]; then
				P_RREV=${_a[1]}
				break
			fi
		done
		
		
		branch_info="(\033[0;32m$P_LREV\033[0;37m"
		if [ "$DIR" != "lo" ]; then
			if [ "$DIR" == "lr" ]; then
				branch_info+=" -> "
			elif [ "$DIR" == "rl" ]; then
				branch_info+=" <- "
			else
				branch_info+=" <-> "
			fi
			branch_info+="\033[0;31m$P_RREV\033[0;37m"
		fi
		branch_info+=")"
		
		echo -e "### $_cmd_info: \033[1;37m${P_NAME}\033[0;37m $branch_info ###"
		
		
		eval "__d \"Working in $PWD\""
		
		
		for cmd in "$@"; do
			if [ $__dry_run -ne 1 ]; then
				eval "__d \"Run: $cmd\""
			
				eval $cmd
				exit_code=$?
			else
				eval "__d \"Dry run: $cmd\""

				exit_code=0
			fi
			
			__d "Returned with: $exit_code" 
			
			if [ $exit_code -eq 255 ]; then
				break	# not an error. just skip the subsequent commands
			elif [ $exit_code -ne 0 ]; then
				__failed
				break;
			fi
		done
		
		if [ $__last_git_failed -ne 0 ]; then
			break
		fi
	done
			

	cd $ORIG_PATH
	
	
	trap - INT TERM
	
	
	if [ $__last_git_failed -ne 0 ]; then
		return 2
	fi
}


__egit()
{
	__set_base
	
	if [ $? -ne 0 ]; then
		echo "Not running within a repo root directory"
		return 1
	fi
	
	
	# parse options
	OPTIONS=()
	_opt_end=0
	read_repo_options=()
	for _opt in "$@"; do
		if [ $_opt_end -eq 0 -a "${_opt:0:2}" == "-r" ]; then
			read_repo_options=("${read_repo_options[@]}" "-f")
		elif [ "${_opt:0:1}" == "@" ]; then
			read_repo_options=("${read_repo_options[@]}" "${_opt:1}")
		else
			OPTIONS=("${OPTIONS[@]}" "$_opt")
			_opt_end=1
		fi
	done
	

	# intern commands
	if [ "${OPTIONS[0]}" == "rebuild" ]; then
		__build_egit_manifest "force"
		return $?
	
	elif [ "${OPTIONS[0]}" == "version" ]; then
		echo "egit version 1.0"
		echo ""
		echo -e "Copyright 2012 Daniel Volk <mail@volkarts.com>"
		echo ""

		return 0
	
	elif [ "${OPTIONS[0]}" == "" -o "${OPTIONS[0]}" == "help" ]; then
		echo "usage: egit [-r] <egit command> [git options] [@<project pattern>] ..."
		echo "       egit rebuild"
		echo ""
		echo "  egit command:"
		echo "    gui       run git gui in any repo that has a dirty working tree"
		echo "    gui!      run git gui whether the working tree is dirty or not"
		echo "    gitk,k    run gitk in every repo and return immediatly"
		echo "    update    update repos from a given remote"
		echo "    upload    upload every repo to a given remote"
		echo "    rebuild   rebuild the egit project list"
		echo "    version   show version"
		echo "    help      show this help"
		echo "    <all valid git commands>"
		echo ""
		echo "  options:"
		echo "    -r        rebuild the egit project list before running the command"
		echo "    [git options] all options valid to the specified git command"
		echo ""
		echo "  project patterns:"
		echo "    [@<project patterns>] allows to filter project by name"
		echo "                          only parts of the project name need to be given"
		echo "                          multiple definitions are possible"
		echo ""
		echo "Copyright 2012 Daniel Volk <mail@volkarts.com>"
		echo ""
		
		return 1

	fi
	
	
	__read_repo "${read_repo_options[@]}"
	

	# git commands
	if [ "${OPTIONS[0]}" == "gui" ]; then
		commands=( \
			"${OPTIONS[0]}" \
			'__repo_status' \
			'git gui' \
		)
		
	elif [ "${OPTIONS[0]}" == "gui!" ]; then
		unset OPTIONS[0]
		
		commands=( \
			"gui!" \
			"git gui ${OPTIONS[*]}" \
		)
		
	elif [ "${OPTIONS[0]}" == "update" ]; then
		if [ "${OPTIONS[1]}" == "" ]; then
			echo "usage: egit ${OPTIONS[0]} <remote> [remote branch]"
			return 1
		fi

		commands=( \
			"${OPTIONS[0]}" \
			"!rb:${OPTIONS[2]}" \
			"!dir:rl" \
			"git fetch ${OPTIONS[1]}" \
			"git merge ${OPTIONS[1]}/\$P_RREV" \
		)
		
	elif [ "${OPTIONS[0]}" == "upload" ]; then
		if [ "${OPTIONS[1]}" == "" ]; then
			echo "usage: egit ${OPTIONS[0]} <remote> [local branch]"
			return 1
		fi

		commands=( \
			"${OPTIONS[0]}" \
			"!lb:${OPTIONS[2]}" \
			"!dir:lr" \
			"git push ${OPTIONS[1]} \$P_LREV" \
		)
		
	elif [ "${OPTIONS[0]}" == "gitk" -o "${OPTIONS[0]}" == "k" ]; then
		if [ "${OPTIONS[0]}" == "k" ]; then
			OPTIONS[0]="gitk"
		fi
		
		commands=( \
			"${OPTIONS[0]}" \
			"${OPTIONS[*]} &" \
		)
		
	else
		commands=( \
			"${OPTIONS[0]}" \
			"git ${OPTIONS[*]}" \
		)
		
	fi

	
	__exec_git "${commands[@]}"
}


# run main
__egit "$@"
exit $?
