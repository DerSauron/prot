#!/bin/bash

#
# Copyright 2012 by Daniel Volk <mail@volkarts.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

__debug=0
__dry_run=0


BASE_PATH=


PROJECTS=()

	
__d()
{
	[ $__debug -eq 1 ] && echo -e "\e[1;30mDEBUG $1\e[0m"
}


__set_base()
{
	BASE_PATH=$PWD
	
	while [ "$BASE_PATH" != "" ]; do
		if [ -e "$BASE_PATH/.repo/manifest.xml" ]; then
			return 0
		fi
		
		BASE_PATH=`basename "$BASE_PATH"`
	done
	
	return 1
}


__build_egit_manifest()
{
	if [ \
		"$BASE_PATH/.repo/manifest.xml" -nt "$BASE_PATH/.repo/egit_project.list" -o \
		"$BASE_PATH/.repo/local_manifest.xml" -nt "$BASE_PATH/.repo/egit_project.list" -o \
		"$1" == "force" \
		]; then		
		bo=\(
		bc=\)
		t=\`
		
		PERL_CODE=$(cat <<PERL_CODE

\$file = "";

open${bo}FILE, "<$BASE_PATH/.repo/manifest.xml"$bc or die "Cannot load repo list\n";
\$file .= \$_ while ( <FILE> );
close(FILE);

if ( -e "$BASE_PATH/.repo/local_manifest.xml" )
{
	open${bo}FILE, "<$BASE_PATH/.repo/local_manifest.xml"$bc or die "Cannot load local repo list\n";
	\$file .= \$_ while ( <FILE> );
	close(FILE);
}


\$file =~ s/<!--.*?-->//g;

%projects = ();
@project_list = ();

while ( \$file =~ /<project$bo[^>]+$bc>/g )
{
	\$line = \$1;
	
	\$line =~ /name="$bo[^"]*$bc"/i;
	\$name = \$1;
	
	\$line =~ /path="$bo[^"]*$bc"/i;
	\$path = \$1;
	
	\$name = \$path if ( \$name eq "" );
	
	\$pid = "\$name:\$path";
	
	\$projects{\$path} = \$pid;
	push @project_list, \$path;
}

	
	
if ( -e "$BASE_PATH/.repo/egit_project.list" )
{
	open${bo}FILE, "<$BASE_PATH/.repo/egit_project.list"$bc or die "Cannot load egit project list\n";
	while ( <FILE> )
	{
		\$_ =~ s/[\s\r\n]+$/\1/s;
		@pdef = split /:/;
		
		if ( \$projects{\$pdef[1]} )
		{
			\$projects{\$pdef[1]} = "\$projects{\$pdef[1]}:\$pdef[2]";
		}
	}
	close(FILE);
}


open${bo}FILE, ">$BASE_PATH/.repo/egit_project.list"$bc or die "Cannot write egit project list\n";
foreach ( @project_list )
{
	print FILE "\$projects{\$_}\n";
}
close(FILE);

PERL_CODE
		)
	
		#echo $PERL_CODE
	
		echo $PERL_CODE | perl
		return $?
	fi
}	
	
__read_repo()
{
	__build_egit_manifest "$@"
	
	if [ $? -ne 0 ]; then
		exit $?
	fi
	
	
	PROJECTS=($(cat $BASE_PATH/.repo/egit_project.list))
}


__failed()
{
	__last_git_failed=1
	
	echo -e "\033[1;31mFailed\033[0;37m"
}


# return <skip> when working dir contains no changes
__repo_status()
{
	status=$(git status -s)
	
	if [ "$status" != "" ]; then
		return 0
	else
		return 255
	fi
}


__exit_hook()
{
	cd $ORIG_PATH
	
	exit 3
}


__exec_git()
{
	ORIG_PATH=$PWD
	
	trap __exit_hook INT TERM

	
	__last_git_failed=0

	
	_cmd_info=$(echo $1 | tr '[a-z]' '[A-Z]')
	shift
	
	P_RREV_U=
	DIR=lo
	while [ 1 = 1 ]; do
		internal_cmd=$1
		if [ "${internal_cmd:0:4}" == "!rb:" ]; then
			P_RREV_U=${internal_cmd:4}
			shift
		elif [ "${internal_cmd:0:5}" == "!dir:" ]; then
			DIR=${internal_cmd:5}
			shift
		else
			break
		fi
	done
	
	
	for p in ${PROJECTS[@]}; do
		pattrs=($(echo $p | tr ":" "\n"))
		
		P_NAME=${pattrs[0]}
		P_PATH=${pattrs[1]}

		cd $BASE_PATH/$P_PATH
		if [ $? -ne 0 ]; then
			__failed
			break;
		fi
		
		P_LREV=$(git branch | awk '/^\*/ { print $2 }')

		
		P_RREV=$P_RREV_U
		
		if [ "$P_RREV" == "" ]; then
			P_RREV=$P_LREV
		fi

		mappings=($(echo ${pattrs[2]} | tr "," "\n"))	
		for m in "${mappings[@]}"; do
			_a=($(echo $m | tr "=" "\n"))
			
			if [ "${_a[0]}" == "$P_RREV" ]; then
				P_RREV=${_a[1]}
				break
			fi
		done
		
		
		branch_info="(\033[0;32m$P_LREV\033[0;37m"
		if [ "$DIR" != "lo" ]; then
			if [ "$DIR" == "lr" ]; then
				branch_info+=" -> "
			elif [ "$DIR" == "rl" ]; then
				branch_info+=" <- "
			else
				branch_info+=" <-> "
			fi
			branch_info+="\033[0;31m$P_RREV\033[0;37m"
		fi
		branch_info+=")"
		
		echo -e "### $_cmd_info: \033[1;37m${P_NAME}\033[0;37m $branch_info ###"
		
		
		eval "__d \"Working in $PWD\""
		
		
		for cmd in "$@"; do
			if [ $__dry_run -ne 1 ]; then
				eval "__d \"Run: $cmd\""
			
				eval $cmd
				exit_code=$?
			else
				eval "__d \"Dry run: $cmd\""

				exit_code=0
			fi
			
			__d "Returned with: $exit_code" 
			
			if [ $exit_code -eq 255 ]; then
				break	# not an error. just skip the subsequent commands
			elif [ $exit_code -ne 0 ]; then
				__failed
				break;
			fi
		done
		
		if [ $__last_git_failed -ne 0 ]; then
			break
		fi
	done
			

	cd $ORIG_PATH
	
	
	trap - INT TERM
	
	
	if [ $__last_git_failed -ne 0 ]; then
		return 2
	fi
}


__egit()
{
	__set_base
	
	if [ $? -ne 0 ]; then
		echo "Select a repo first"
		return 1
	fi
	
	
	# parse options
	while [ 1 = 1 ]; do
		_option=$1
		if [ "${_option:0:2}" == "-r" ]; then
			read_repo_options=("force")
		else
			break;
		fi
		
		shift
	done
	
	
	__read_repo "${read_repo_options[@]}"
	

	if [ "$1" == "rebuild" ]; then
		__build_egit_manifest "force"
		return $?
		
	elif [ "$1" == "gui" ]; then
		commands=( \
			"$1" \
			'__repo_status' \
			'git gui' \
		)
		
	elif [ "$1" == "gui!" ]; then
		shift
		
		commands=( \
			"gui!" \
			"git gui $*" \
		)
		
	elif [ "$1" == "update" ]; then
		if [ "$2" == "" ]; then
			echo "usage: egit $1 <remote> [remote branch]"
			return 1
		fi

		commands=( \
			"$1" \
			"!rb:$3" \
			"!dir:rl" \
			"git fetch $2" \
			"git merge $2/\$P_RREV" \
		)
		
	elif [ "$1" == "upload" ]; then
		if [ "$2" == "" ]; then
			echo "usage: egit $1 <remote>"
			return 1
		fi

		commands=( \
			"$1" \
			"!dir:lr" \
			"git push $2 \$P_RREV" \
		)
		
	elif [ "$1" == "gitk" ]; then

		commands=( \
			"$1" \
			"$* &" \
		)
		
	else
		if [ "$1" == "" ]; then
			echo "usage: egit <egit command> ..."
			echo "  egit command:"
			echo -e "    gui       run git gui in any repo that has a dirty working tree"
			echo -e "    gui!      run git gui whether the working tree is dirty or not"
			echo -e "    update    update repos from a given remote"
			echo -e "    upload    upload every repo to a given remote"
			echo -e "    <all valid git commands>"
			
			return 1
		fi
		
		commands=( \
			"$1" \
			"git $*" \
		)
		
	fi
	
	
	__exec_git "${commands[@]}"
}


# run main
__egit "$@"
exit $?
