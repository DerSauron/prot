#!/bin/bash

#
# Copyright 2012-2013 by Daniel Volk <mail@volkarts.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


BASE_PATH=


PROJECTS=()


PROT_VERSION=1.5.1
GIT_GUI=${GIT_GUI:-gui}
GIT_K=${GIT_K:-gitk}


__d()
{
    [ $FLAG_VERBOSITY -ge 3 ] && echo -e "\e[1;30mDEBUG $1\e[0m"
}


__set_base()
{
    BASE_PATH=$PWD

    while [ "$BASE_PATH" != "" -a "$BASE_PATH" != "/" ]; do
        if [ -d	 "$BASE_PATH/.repo" ]; then
            return 0
        fi

        BASE_PATH=`dirname "$BASE_PATH"`
    done

    return 1
}


__build_prot_manifest()
{
    if [ ! -f "$BASE_PATH/.repo/manifest.xml" ]; then
        # no android environment - skip building manifest
        return;
    fi


    local doit

    if [ "$1" != "force" ]; then
        doit=0
        if [ "$BASE_PATH/.repo/manifest.xml" -nt "$BASE_PATH/.repo/prot.list" ]; then
            doit=1
        else
            if [ "$BASE_PATH/.repo/local_manifest.xml" -nt "$BASE_PATH/.repo/prot.list" ]; then
                doit=1
            else
                for f in `ls $BASE_PATH/.repo/local_manifests/*.xml 2>/dev/null`; do
                    if [ "$f" -nt "$BASE_PATH/.repo/prot.list" ]; then
                        doit=1
                        break;
                    fi
                done
            fi
        fi

        if [ $doit -eq 0 ]; then
            return;
        fi
    fi


    bo=\(
    bc=\)
    t=\`

    PERL_CODE=$(cat <<PERL_CODE
\$file = ${t}${bo}cd ${BASE_PATH}; repo list${bc}${t};

%projects = ();
@project_list = ();

while ( \$file =~ /$bo[^\s]+$bc\s*:\s*$bo[^\s]+$bc/gm )
{
    \$path = \$1;
    \$name = \$2;

    \$name = \$path if ( \$name eq "" );

    \$pid = "\$name:\$path";

    if ( !\$projects{\$path} )
    {
        push @project_list, \$path;
    }
    \$projects{\$path} = \$pid;
}

if ( -e "$BASE_PATH/.repo/prot.list" )
{
    open${bo}FILE, "<$BASE_PATH/.repo/prot.list"$bc or die "Cannot load prot project list\n";
    while ( <FILE> )
    {
        \$_ =~ s/[\s\r\n]+\$/\1/s;
        @pdef = split /:/;

        if ( \$projects{\$pdef[1]} )
        {
            if ( \$pdef[0] =~ /^#/ )
            {
                \$projects{\$pdef[1]} = "#\$projects{\$pdef[1]}";
            }

            if ( \$pdef[2] )
            {
                \$projects{\$pdef[1]} = "\$projects{\$pdef[1]}:\$pdef[2]";
            }
        }
    }
    close(FILE);
}


open${bo}FILE, ">$BASE_PATH/.repo/prot.list"$bc or die "Cannot write prot project list\n";
foreach ( @project_list )
{
    \$status = ${t}cd $BASE_PATH/\$_ && git branch | awk '/^\*/ { print \\\$1 \\\$2 \\\$3 }'$t;
    \$status =~ s/[\s\r\n]+\$/\1/s;

    if ( \$status !~ /^\*\(/ )
    {
        print FILE "\$projects{\$_}\n";
    }
}
close(FILE);

PERL_CODE
    )


    echo -n "### Building manifest "
    if [ "$1" == "force" ]; then echo -n "(forced)"; else echo -n "(update)"; fi
    echo " ###"

    echo $PERL_CODE | perl
    return $?
}	


__filter_projects()
{
    if [ $# -eq 0 ]; then
        return
    fi


    declare -a _projects=("${PROJECTS[@]}")

    PROJECTS=()

    for _project in "${_projects[@]}"; do
        for _arg in "$@"; do
            __d "Check $_project against $_arg"

            if echo $_project | grep -i $_arg > /dev/null; then
                PROJECTS=("${PROJECTS[@]}" "$_project")
            fi
        done
    done
}


__git()
{
    if [ $FLAG_VERBOSITY -ge 1 ]; then
        echo -e "\e[1;30mgit $@\e[0m" 1>&2
    fi

    git "$@"
}


__read_repo()
{
    PROJECTS=($(cat $BASE_PATH/.repo/prot.list | grep "^[^#]"))

    __filter_projects "$@"
}


__failed()
{
    __last_git_failed=1

    echo -e "\033[1;31mFailed\033[0m" 1>&2
}


# return <skip> when working dir contains no changes
__repo_status()
{
    local status

    if [ "$1" == "--skip-untracked" ]; then
        status=$(__git status -s | grep -v "^??" )
    else
        status=$(__git status -s)
    fi

    if [ "$status" != "" ]; then
        return 0
    else
        return 255
    fi
}


__exit_hook()
{
    cd $ORIG_PATH

    exit 3
}


__translate_ref()
{
    local mappings=($(echo $1 | tr "," "\n"))
    local _a
    local _rm
    local result=

    for m in "${mappings[@]}"; do
        _a=($(echo $m | tr "=" "\n"))

        _rm=($(echo ${_a[0]} | tr "/" "\n"))
        if [ "${_rm[1]}" != "" ]; then
            if [ "${_rm[0]}" == "$3" -a "${_rm[1]}" == "$2" ]; then
                __d "Translating branch '$2' to '${_a[1]}' for remote '${_rm[0]}'"
                TREF="${_a[1]}"
                return 0
            fi
        else
            if [ "${_a[0]}" == "$2" -a "$result" == "" ]; then
                # do not return imediately since a matching branch with
                # a matching remote wins
                result="${_a[1]}"
            fi
        fi
    done

    if [ "$result" == "" ]; then
        __d "Not Translating branch '$2'"
        TREF="$2"
    else
        __d "Translating branch '$2' to '${_a[1]}'"
        TREF="$result"
    fi
    return 0
}


__get_local_branch()
{
    echo $(__git branch | awk '/^\*/ { print $2 }')
}


__switch_branch_temp()
{
    if [ "$LOCAL_BRANCH" == "$1" ]; then
        return 0
    fi


    __repo_status --skip-untracked
    if [ $? -eq 0 ]; then
        echo "Working directory dirty. Commit your changes first."
        return 1
    fi


    echo "Switching to branch $1 for update"

    __git checkout "$1"
    if [ $? -ne 0 ]; then
        return $?
    fi


    return 0
}


__switch_back_branch_temp()
{
    local ret

    if [ "$LOCAL_BRANCH" == "$1" ]; then
        return 0
    fi


    echo -n "Switching back to branch $LOCAL_BRANCH"
    if [ "$2" == "--rebase" ]; then
        echo " and rebase to $1"
    else
        echo ""
    fi

    __git checkout "$LOCAL_BRANCH"
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi


    if [ "$2" == "--rebase" ]; then
        __git rebase "$1"
        ret=$?
        if [ $ret -ne 0 ]; then
            return $ret
        fi
    fi


    return 0
}


__update()
{
    local ret
    local current_branch
    local temp_name=
    local remote


    remote=`__git remote | grep "$P_REMOTE"`
    if [ "$remote" != "$P_REMOTE" ]; then
        # this repository doesn't have this remote. Skip it.
        echo "No such remote '$P_REMOTE'. Skip update."
        return 255
    fi

    __git fetch $P_REMOTE
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi

    local not_merged=`__git branch -r --no-merged | grep "$P_REMOTE/$P_RREV"`
    if [ "$not_merged" == "" ]; then
        # nothing to do - remote branch is already merged
        return 0
    fi


    __repo_status --skip-untracked
    if [ $? -eq 0 ]; then
        # repo dirty? stash changes
        temp_name=prot_update_temp_$$
        current_branch=`__get_local_branch`
        __git stash save "$temp_name"
    fi


    __switch_branch_temp $P_LREV
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi

    __git merge --no-edit $P_REMOTE/$P_RREV
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi

    __switch_back_branch_temp $P_LREV $1
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi


    if [ "$temp_name" != "" ]; then
        __git stash pop
        ret=$?
        if [ $ret -ne 0 ]; then
            echo "stash pop failed with conflicts. Solve it and run 'prot @$P_NAME stash drop" 1>&2
            return $ret
        fi
    fi


    # update submodules
    __git submodule update --init
}


__upload()
{
    local ret


    remote=`__git remote | grep "$P_REMOTE"`
    if [ "$remote" != "$P_REMOTE" ]; then
        # this repository doesn't have this remote. Skip it.
        echo "No such remote '$P_REMOTE'. Skip upload."
        return 255
    fi

    __switch_branch_temp $P_LREV
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi

    __git push $P_REMOTE $P_LREV:$P_RREV
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi

    __switch_back_branch_temp $P_LREV
    ret=$?
    if [ $ret -ne 0 ]; then
        return $ret
    fi
}


__launch_gui_with_shell()
{
    local gui_cmd

    if [ "$1" == "citool" ]; then
        gui_cmd="gui citool"
    else
        gui_cmd="$GIT_GUI"
    fi

    # run git gui async to allow to start a shell
    ( __git $gui_cmd 2>&1 >/dev/null ) &
    local gui_pid=$!

    # only launch the shell when called from a tty
    local shell_pid
    if [ -t 0 ]; then
        (
            should_exit=0
            while true; do
                echo "Type 's' to enter a shell"
                while true; do
                    trap '{ stty echo; exit 255; }' SIGTERM SIGINT
                    read -n 1 -s INP </dev/tty
                    trap - SIGTERM SIGINT
                    if [ "$INP" == "s" -o "$INP" == "S" ]; then
                        break;
                    fi
                done
                trap 'should_exit=1' SIGTERM
                (
                    echo "Entering a shell. You are in the repositories root directory."
                    echo "When you change files, remember to do a rescan in git gui."
                    echo "Type 'exit' to exit the shell."
                    local rcfile=`mktemp`
                    cat >$rcfile <<'EOF'
[ -e ~/.bashrc ] && source ~/.bashrc
PS1="git $(__git_ps1 '(\e[0;35m%s\e[0m)')> "
EOF
                    bash --rcfile $rcfile </dev/tty
                    rm $rcfile
                )
                trap - SIGTERM
                if [ $should_exit -eq 1 ]; then
                    break;
                fi
            done
        ) &
        shell_pid=$!
    else
        echo "stdin is not a terminal. Cannot launch a shell."
        shell_pid=
    fi

    # wait for git gui to finish
    wait $gui_pid
    local ret=$?
    if echo "`jobs -p`" | grep "$gui_pid" >/dev/null 2>&1; then
        ( kill -s TERM $gui_pid 2>/dev/null ) &
        wait $gui_pid 2>/dev/null
        ret=$?
    fi

    # stop shell, if any
    if [ ! -z "$shell_pid" ]; then
        if echo "`jobs -p`" | grep "$shell_pid" >/dev/null 2>&1; then
            echo "Waiting for user shell to exit"
            ( kill -s TERM $shell_pid 2>/dev/null ) &
            wait $shell_pid 2>/dev/null
            if [ -t 0 ]; then
                # just in case we kill the silent read
                stty echo
            fi
        fi
    fi

    # $ret is git gui's exit code
    return $ret
}


__git_gui()
{
    local ret

    if [ "$1" != "forced" ]; then
        if [ -n "`git branch | grep "\* staging"`" ]; then
            echo "Starting feature mode"
            __feature
            ret=$?
            if [ $ret -ne 255 ]; then
                return $ret
            fi
        else
            echo "Working directory is dirty. Starting git gui ..."
        fi

        if [ "$1" != "" -a "$LOCAL_BRANCH" != "$1" ]; then
            __git checkout "$1"
            ret=$?
            if [ $ret -ne 0 ]; then
                return $ret
            fi
        fi
    else
        shift
    fi

    # run git gui async with a shell
    __launch_gui_with_shell
    ret=$?

    # $ret is git gui's exit code
    if [ $ret -ne 0 ]; then
        return $ret
    fi

    if [ "$1" != "forced" -a "$1" != "" -a "$LOCAL_BRANCH" != "$1" ]; then
        __git rebase "$1" "$LOCAL_BRANCH"
        ret=$?
        if [ $ret -ne 0 ]; then
            return $ret
        fi
    fi

    return 0
}


__exec_git()
{
    ORIG_PATH=$PWD

    trap __exit_hook INT TERM


    local __last_git_failed=0


    local _cmd_info=$(echo $1 | tr '[a-z]' '[A-Z]')
    shift

    P_RREV_U=
    P_LREV_U=
    DIR=lo
    P_REMOTE=
    while [ 1 = 1 ]; do
        internal_cmd=$1
        if [ "${internal_cmd:0:4}" == "!rb:" ]; then
            P_RREV_U=${internal_cmd:4}
            shift
        elif [ "${internal_cmd:0:4}" == "!lb:" ]; then
            P_LREV_U=${internal_cmd:4}
            shift
        elif [ "${internal_cmd:0:5}" == "!dir:" ]; then
            if [ "${internal_cmd:7:1}" == ":" ]; then
                P_REMOTE=${internal_cmd:8}
            fi
            DIR=${internal_cmd:5:2}
            shift
        else
            break
        fi
    done


    for p in ${PROJECTS[@]}; do
        P_ATTRS=($(echo $p | tr ":" "\n"))

        P_NAME=${P_ATTRS[0]}
        P_PATH=${P_ATTRS[1]}
        P_TRANSTABLE=${P_ATTRS[2]}


        cd $BASE_PATH/$P_PATH 2>/dev/null
        if [ $? -ne 0 ]; then
            echo -e "\033[1;31mCannot switch to directory \033[0;36m$P_PATH\033[1;31m for project \033[0;36m$P_NAME\033[1;31m: Directory does not exists\033[0m" 1>&2
            __failed
            break;
        fi


        LOCAL_BRANCH=$(__get_local_branch)


        P_LREV=$P_LREV_U
        if [ "$P_LREV" == "" ]; then
            P_LREV=$LOCAL_BRANCH
        fi

        __translate_ref "$P_TRANSTABLE" "$P_LREV" "$P_REMOTE"
        P_LREV="$TREF"


        P_RREV=$P_RREV_U

        if [ "$P_RREV" == "" ]; then
            P_RREV=$P_LREV
        fi

        __translate_ref "$P_TRANSTABLE" "$P_RREV" "$P_REMOTE"
        P_RREV="$TREF"


        # export vars
        export P_PATH
        export P_LREV
        export P_RREV


        local branch_info="(\033[0;32m$P_LREV\033[0;37m"
        if [ "$LOCAL_BRANCH" != "$P_LREV" ]; then
            branch_info+="[\033[0;32m$LOCAL_BRANCH\033[0;37m]"
        fi
        if [ "$DIR" != "lo" ]; then
            if [ "$DIR" == "lr" ]; then
                branch_info+=" -> "
            elif [ "$DIR" == "rl" ]; then
                branch_info+=" <- "
            else
                branch_info+=" <-> "
            fi
            branch_info+="\033[0;31m$P_RREV\033[0;37m"
        fi
        branch_info+=")"

        echo -e "### $_cmd_info: \033[1;37m${P_NAME}\033[0;37m $branch_info ###"


        eval "__d \"Working in $PWD\""


        for cmd in "$@"; do
            if [ $FLAG_DRYRUN -ne 1 ]; then
                if [ $FLAG_VERBOSITY -ge 1 ]; then
                    eval "echo -e \"\e[1;30m(MAIN CMD): $cmd\e[0m\""
                else
                    eval "__d \"Run cmd: $cmd\""
                fi

                eval $cmd
                exit_code=$?
            else
                eval "echo -e \"\e[0;36m(DRY RUN): $cmd\e[0m\""

                exit_code=0
            fi

            __d "Returned with: $exit_code"

            if [ $exit_code -eq 255 ]; then
                break	# not an error. just skip the subsequent commands
            elif [ $exit_code -eq 254 ]; then
                return 0	# not an error. User whats to exit
            elif [ $exit_code -ne 0 ]; then
                __failed
                break;
            fi
        done

        if [ $__last_git_failed -ne 0 ]; then
            break
        fi
    done


    cd $ORIG_PATH


    trap - INT TERM


    if [ $__last_git_failed -ne 0 ]; then
        return 2
    fi
}


__usage()
{
    if [ $FLAG_HELP -eq 0 ]; then
        # error
        if [ "$1" == "" ]; then
            echo "ERROR: No command specified" 1>&2
        else
            echo "ERROR: Missing options for command" 1>&2
        fi
        echo ""
    fi

    if [ "$1" == "" -a $FLAG_HELP -eq 1 ]; then
        echo "usage: prot [prot options] [--] <prot command> [git options] [@<project pattern>] ..."

        if [  $FLAG_HELP -eq 1 ]; then
            echo "       prot --help|-h"
            echo "       prot --rebuild|-r"
            echo "       prot --version"
            echo ""
            echo "  prot command:"
            echo "    gui       run git gui in any repo that has a dirty working tree"
            echo "    gui!      run git gui whether the working tree is dirty or not"
            echo "    gitk|k    run gitk in every repo"
            echo "    update    update repos from a given remote"
            echo "    upload    upload every repo to a given remote"
            echo "    help      show this help"
            echo "    gc        run garbage collector"
            echo "    backup    mirror repository to a remote backup repository"
            echo "    <any valid git commands>"
            echo "              runs the given git command with its arguments"
            echo "    custom    run custom shell command"
            echo ""
            echo "  prot options:"
            echo "    --help|-h           if specified along with a prot command show detailed help"
            echo "                        for this command. Show this help screen otherwise"
            echo "    --dry-run           don't do anything that would hurt"
            echo "    --rebuild|-r        rebuild the prot project list before running any command"
            echo "    --version           show version number and exit"
            echo ""
            echo "  git options:"
            echo "    all options valid to the specified git command"
            echo ""
            echo "  project patterns:"
            echo "    [@<project patterns>] allows to filter project by name"
            echo "                          only parts of the project name need to be given"
            echo "                          multiple definitions are possible"
        fi
    elif [ "$1" == "version" ]; then
        echo "prot version $PROT_VERSION"

    elif [ "$1" == "gui" ]; then
        echo "usage: prot $1 [local branch]"
        if [  $FLAG_HELP -eq 1 ]; then
            echo ""
            echo "  local branch:"
            echo "    If specified and differs from currently checked out branch prot first"
            echo "    switch to <local branch>, run git gui as normal and then rebase the former"
            echo "    branch to the new top of <local branch>"
        else
            echo "       prot $1 --help"
        fi
    elif [ "$1" == "gitk" -o "$1" == "k" ]; then
        echo "Usage: prot gitk [--parallel]"
        if [  $FLAG_HELP -eq 1 ]; then
            echo ""
            echo "  --parallel:"
            echo "    Start all gitk's in all repositories at once"
        else
            echo "       prot gitk --help"
        fi
    elif [ "$1" == "update" ]; then
        echo "usage: prot $1 <remote> [remote branch [local branch [--rebase]]]"

    elif [ "$1" == "upload" ]; then
        echo "usage: prot $1 <remote> [remote branch [local branch]]"

    elif [ "$1" != "" ]; then
        echo "No detailed help for command '$1' available. Try 'prot --help'"

    fi

    if [ $FLAG_HELP -eq 0 ]; then
        local cmd=$1
        if [ "$cmd" != "" ]; then
            cmd="$cmd "
        fi

        echo ""
        echo "For detailed help run 'prot $cmd--help'"

    fi

    echo ""
    echo "Copyright 2012-2013 Daniel Volk <mail@volkarts.com>"
    echo ""
}


__prot()
{
    __set_base

    if [ $? -ne 0 ]; then
        echo "Not running within a repo root directory" 1>&2
        return 1
    fi


    # options
    OPTIONS=()

    # defaults
    FLAG_REBUILD=0
    FLAG_DRYRUN=0
    FLAG_VERBOSITY=0
    FLAG_HELP=0

    # translate long options
    local _args=
    for _opt; do
        local _delim=""
        local _sopt

        case "$_opt" in
            --rebuild)	_sopt="-r" ;;
            --dry-run)	_sopt="-u" ;;
            --help)		_sopt="-h" ;;
            --version)	_sopt="-x" ;;
            *)	[[ "${_opt:0:1}" == "-" ]] || _delim="'"
                _sopt="${_delim}${_opt}${_delim}" ;;
        esac

        _args="${_args}${_sopt} "
    done
    eval set -- $_args

    # parse options
    repo_filter=()
    _opt_end=0
    for _opt in "$@"; do
        if [ "${_opt}" == "--" ]; then
            _opt_end=1
        elif [ $_opt_end -eq 0 -a "${_opt:0:1}" == "-" -a "${_opt:0:2}" != "--" ]; then
            OPTIND=0
            while getopts ":ruvhx" flag "$_opt"; do
                case "$flag" in
                    r) FLAG_REBUILD=1 ;;
                    u) FLAG_DRYRUN=1 ;;
                    v) FLAG_VERBOSITY=$((FLAG_VERBOSITY + 1)) ;;
                    h) FLAG_HELP=1 ;;
                    x) FLAG_HELP=1 OPTIONS=("${OPTIONS[@]}" "version") ;;
                    :) echo "Missing argument for $OPTARG" 1>&2
                        return 1
                        ;;

                    ?)	OPTIONS=("${OPTIONS[@]}" "$_opt")	# pass it to git
                        ;;
                esac
            done
        elif [ "${_opt:0:1}" == "@" ]; then
            repo_filter=("${repo_filter[@]}" "${_opt:1}")
        else
            OPTIONS=("${OPTIONS[@]}" "$_opt")
        fi
    done


    # help
    if [ $FLAG_HELP -eq 1 -o $FLAG_REBUILD -eq 0 -a "${OPTIONS[0]}" == "" ]; then
        __usage "${OPTIONS[0]}"

        if [ "${OPTIONS[0]}" == "" ]; then
            return 1
        else
            return 0
        fi
    fi


    # update manifest
    local force=
    if [ $FLAG_REBUILD -eq 1 ]; then
        force="force"
    fi

    __build_prot_manifest $force
    local _ret=$?
    if [ $_ret -ne 0 ]; then
        return $_ret
    fi

    if [ $FLAG_REBUILD -eq 1 -a "${OPTIONS[0]}" == "" ]; then
        # rebuild only
        return 0
    fi


    # read repo
    __read_repo "${repo_filter[@]}"


    # git commands
    if [ "${OPTIONS[0]}" == "gui" ]; then
        commands=( \
            "${OPTIONS[0]}" \
            "!lb:${OPTIONS[1]}" \
            '__repo_status' \
            "__git_gui \$P_LREV" \
        )

    elif [ "${OPTIONS[0]}" == "gui!" ]; then
        unset OPTIONS[0]

        commands=( \
            "gui!" \
            "__git_gui forced ${OPTIONS[*]}" \
        )

    elif [ "${OPTIONS[0]}" == "gitk" -o "${OPTIONS[0]}" == "k" ]; then
        local _par=
        OPTIONS[0]=$GIT_K
        if [ "${OPTIONS[1]}" == "--parallel" ]; then
            _par='&'
        fi
        commands=( \
            "${OPTIONS[0]}" \
            "${OPTIONS[*]} $_par >/dev/null" \
        )

    elif [ "${OPTIONS[0]}" == "update" ]; then
        if [ "${OPTIONS[1]}" == "" ]; then
            __usage "${OPTIONS[0]}"
            return 1
        fi

        commands=( \
            "${OPTIONS[0]}" \
            "!rb:${OPTIONS[2]}" \
            "!lb:${OPTIONS[3]}" \
            "!dir:rl:${OPTIONS[1]}" \
            "__update ${OPTIONS[4]}"
        )

    elif [ "${OPTIONS[0]}" == "upload" ]; then
        if [ "${OPTIONS[1]}" == "" ]; then
            __usage "${OPTIONS[0]}"
            return 1
        fi

        commands=( \
            "${OPTIONS[0]}" \
            "!rb:${OPTIONS[2]}" \
            "!lb:${OPTIONS[3]}" \
            "!dir:lr:${OPTIONS[1]}" \
            "__upload" \
        )

    elif [ "${OPTIONS[0]}" == "gc" ]; then
        commands=( \
            "${OPTIONS[0]}" \
            "__git pack-refs --prune" \
            "__git reflog expire --all" \
            "__git repack -a -d -l" \
            "__git rerere gc" \
        )

    elif [ "${OPTIONS[0]}" == "backup" ]; then
        if [ "${OPTIONS[1]}" == "" ]; then
            OPTIONS[1]="backup"
        fi

        commands=( \
            "${OPTIONS[0]}" \
            "!dir:lr:${OPTIONS[1]}" \
            "__git push --mirror ${OPTIONS[1]}" \
        )

    elif [ "${OPTIONS[0]}" == "custom" ]; then
        local cmdname=`basename ${OPTIONS[1]}`
        local _cmd_name="${OPTIONS[0]}($cmdname)"
        unset OPTIONS[0]

        commands=( \
            "$_cmd_name" \
            "${OPTIONS[*]}" \
        )

    else
        commands=( \
            "${OPTIONS[0]}" \
            "__git ${OPTIONS[*]}" \
        )

    fi


    __exec_git "${commands[@]}"
}


# run main
__prot "$@"
exit $?

# kate space-indent on; indent-width 4; mixed-indent off; indent-mode cstyle;
